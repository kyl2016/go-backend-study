
 
## ASCII 
ASCII American Standard Code for Information Interchange，美国信息交换标准代码

计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。
ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。

## Unicode
如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode 编码规范中的编码格式定义的是：字符与字节序列之间的转换方式。

## UTF-8
UTF 是 UCS Transformation Format 的缩写。UCS 是 Universal Character Set 的缩写，也可代表 Unicode Character Set。UTF 也可被翻译为 Unicode 转换格式。它代表的是字符与字节序列的转换方式。
UTF-8 是 Unicode 的实现方式之一。
UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8，“-”右边的整数表示以多少个比特位作为一个编码单元。UTF-8 会以8个比特，也就是一个字节，作为一个编码单元。

UTF-8 的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
下表总结了编码规则，字母x表示可用编码的位。
[编码规则](https://img2018.cnblogs.com/blog/595142/201905/595142-20190516230619261-1231201884.png)
跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

下面，还是以汉字严为例，演示如何实现 UTF-8 编码。

严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。

越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。

编号范围	            字节
0x0000 - 0x007F     1
0x0080 - 0x07FF	    2
0x0800 - 0xFFFF	    3
0x010000 - 0x10FFFF	4

## Go 编码
Go 语言的所有源代码，都必须按照 Unicode 编码规范中的 UTF-8 编码格式进行编码。
在计算机系统的内部，抽象的字符会被编码为整数。这些整数的范围被称为**代码空间**。在代码空间之内，每一个特定的整数都被成为一个代码点。
Unicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符‘a’的 Unicode 代码点是 U+0061。在 Unicode 编码规范中，一个字符能且只能由与它对应的那个代码点表示。

### 一个 string 类型的值在底层是怎样被表达的？
在底层，一个 string 类型的值是由一系列相对应的 Unicode 代码点的 UTF-8 编码值来表达的。就是一个能够表达若干个 UTF-8 编码值的**字节**序列。
一个 string 类型的值既可以被拆分为一个包含多个**字符**（rune）的序列，也可以被拆分为一个包含多个**字节**（byte）的序列。
rune，一个值就代表一个字符，即：一个 Unicode 字符。一个 rune 类型的值会由四个字节宽度的空间来存储。
一个 rune 类型的值在底层其实就是一个 UTF-8 编码值。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）内在表达。

type rune = int32
type byte = uint8

```
var s string = "Go爱好者"
	fmt.Printf("The string: %q\n", s)
	fmt.Printf("	=> runes(char): %q\n", []rune(s))
	fmt.Printf("	=> runes(hex): %x\n", []rune(s))
	fmt.Printf("	=> runes(dec): %d\n", []rune(s))
	fmt.Printf("	=> bytes(hex): [% x]\n", []byte(s))

// 输出内容：
The string: "Go爱好者"
	=> runes(char): ['G' 'o' '爱' '好' '者']
	=> runes(hex): [47 6f 7231 597d 8005]
	=> runes(dec): [71 111 29233 22909 32773]
	=> bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]
```
对应的字节：
```
	=> bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]
```
比前面的字符切片明显长了很多，因为一个中文字符的 UTF-8 编码值需要用三个字节来表达。

[字符串的底层表示](https://static001.geekbang.org/resource/image/0d/85/0d8dac40ccb2972dbceef33d03741085.png)

### 使用带有 range 子句的 for 语句遍历字符串值的时候应该注意什么？
带有 range 子句的 for 语句会先把遍历的字符串值拆成一个字节序列，然后在师徒找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。
```
	for i, c := range s {
		fmt.Printf("%d %q [% x]\n", i, c, []byte(string(c)))
	}
```
变量 i 为当前字节序列中的某个 UTF-8 编码值的第一个字节所对应的那个索引值。
变量 c 为这个 UTF-8 编码值代表的那个 Unicode 字符，其类型会是 rune。
打印内容：
```
0 'G' [47]
1 'o' [6f]
2 '爱' [e7 88 b1]
5 '好' [e5 a5 bd]
8 '者' [e8 80 85]
```
第一行`0 'G' [47]`，第一个单字节字符，十六进制为 47。
第三行`2 '爱' [e7 88 b1]`，是第三个 Unicode 字符，是一个中文字符，有字节序列值的低三、四、五个字节共同表达，其十六进制也不再是单一的整数，而是`e7 88 b1`。